from __future__ import annotations

import asyncio
from typing import Any

import httpx

from brace_backend.core.config import settings
from brace_backend.core.logging import logger
from brace_backend.db.session import session_manager
from brace_backend.db.uow import UnitOfWork
from brace_backend.services.support_chat_service import support_chat_service
from brace_backend.services.support_service import support_service
from brace_backend.domain.support import SupportTicket


class SupportBot:
    def __init__(self) -> None:
        self.token = (settings.support_bot_token or "").strip()
        self.support_chats = set(settings.support_chat_ids or [])
        self.admins = set(settings.admin_chat_ids or [])
        self.api_base = f"https://api.telegram.org/bot{self.token}"
        self.offset = 0

    def _status_keyboard(self, ticket_id: str, current: str) -> dict[str, Any]:
        return {
            "inline_keyboard": [
                [
                    {
                        "text": "✅ Открыт" if current == "open" else "Открыть",
                        "callback_data": f"status:{ticket_id}:open",
                    },
                    {
                        "text": "✅ Закрыт" if current == "closed" else "Закрыть",
                        "callback_data": f"status:{ticket_id}:closed",
                    },
                ]
            ]
        }

    async def _send_status_message(
        self, client: httpx.AsyncClient, *, ticket: SupportTicket, status: str, chat_id: int, thread_id: int | None
    ) -> None:
        payload: dict[str, Any] = {
            "chat_id": chat_id,
            "text": f"Статус тикета обновлён: {status}",
            "reply_markup": self._status_keyboard(str(ticket.id), status),
        }
        if thread_id is not None:
            payload["message_thread_id"] = thread_id
        try:
            await client.post(f"{self.api_base}/sendMessage", json=payload)
        except Exception as exc:  # pragma: no cover
            logger.warning("support_bot_status_notify_failed", ticket_id=str(ticket.id), error=str(exc))

    async def _set_status(
        self,
        client: httpx.AsyncClient,
        *,
        ticket: SupportTicket,
        status: str,
        chat_id: int,
        thread_id: int | None,
    ) -> None:
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            fresh = await uow.support_tickets.get(ticket.id)
            if fresh is None:
                return
            await support_service.update_status(uow, ticket=fresh, status=status)
            ticket = fresh
        await self._send_status_message(client, ticket=ticket, status=status, chat_id=chat_id, thread_id=thread_id)
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            user = await uow.users.get(ticket.user_id)
        if user and user.telegram_id:
            try:
                await client.post(
                    f"{self.api_base}/sendMessage",
                    json={"chat_id": user.telegram_id, "text": f"Статус тикета {ticket.subject} обновлён: {status}"},
                )
            except Exception as exc:  # pragma: no cover - logging only
                logger.warning("support_bot_status_user_notify_failed", user_id=str(user.id), error=str(exc))

    async def _process_callback(self, client: httpx.AsyncClient, callback: dict[str, Any]) -> None:
        data = callback.get("data") or ""
        from_user = (callback.get("from") or {}).get("id")
        message = callback.get("message") or {}
        chat = message.get("chat") or {}
        chat_id = chat.get("id")
        thread_id = message.get("message_thread_id")

        if from_user not in self.admins:
            return
        parts = data.split(":")
        if len(parts) != 3 or parts[0] != "status":
            return
        ticket_id, status = parts[1], parts[2]
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            ticket = await uow.support_tickets.get(ticket_id)
        if not ticket:
            return
        await self._set_status(client, ticket=ticket, status=status, chat_id=chat_id, thread_id=thread_id)
        try:
            await client.post(
                f"{self.api_base}/answerCallbackQuery",
                json={"callback_query_id": callback.get("id"), "text": "Статус обновлён"},
            )
        except Exception:
            pass

    async def _process_message(self, client: httpx.AsyncClient, message: dict[str, Any]) -> None:
        chat = message.get("chat", {})
        chat_id = chat.get("id")
        thread_id = message.get("message_thread_id")
        text = message.get("text") or message.get("caption")
        sender = message.get("from", {})
        sender_id = sender.get("id")
        is_bot = sender.get("is_bot")
        logger.info(
            "support_bot_update",
            chat_id=chat_id,
            thread_id=thread_id,
            has_text=bool(text),
            is_bot=is_bot,
            message_id=message.get("message_id"),
        )
        if not isinstance(chat_id, int) or chat_id not in self.support_chats:
            return
        if not isinstance(thread_id, int):
            return
        if not text or is_bot:
            return
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            ticket: SupportTicket | None = await uow.support_tickets.find_by_thread_id(thread_id)
        if not ticket:
            logger.info("support_bot_unknown_thread", thread_id=thread_id)
            return

        normalized = text.strip().lower()
        if sender_id in self.admins and normalized in {"/close", "close", "закрыть"}:
            await self._set_status(client, ticket=ticket, status="closed", chat_id=chat_id, thread_id=thread_id)
            return
        if sender_id in self.admins and normalized in {"/open", "open", "открыть"}:
            await self._set_status(client, ticket=ticket, status="open", chat_id=chat_id, thread_id=thread_id)
            return
        if sender_id in self.admins and normalized in {"/status", "status", "статус", "кнопки", "кнопка"}:
            await self._send_status_message(client, ticket=ticket, status=ticket.status, chat_id=chat_id, thread_id=thread_id)
            return

        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            fresh = await uow.support_tickets.get(ticket.id)
            if not fresh:
                return
            ticket = fresh
            await support_chat_service.add_admin_message(uow, ticket=ticket, text=text)
            user = await uow.users.get(ticket.user_id)
            if user and user.telegram_id:
                try:
                    await client.post(
                        f"{self.api_base}/sendMessage",
                        json={"chat_id": user.telegram_id, "text": f"Ответ по тикету {ticket.subject}:\n{text}"},
                    )
                except Exception as exc:  # pragma: no cover - logging only
                    logger.warning("support_bot_user_notify_failed", user_id=str(user.id), error=str(exc))
        return

    async def run(self) -> None:
        if not self.token or not self.support_chats:
            logger.warning("support_bot_disabled", reason="missing_token_or_chats")
            while True:
                await asyncio.sleep(60)

        async with httpx.AsyncClient(timeout=httpx.Timeout(25.0)) as client:
            logger.info("support_bot_started", chats=len(self.support_chats))
            while True:
                try:
                    response = await client.post(
                        f"{self.api_base}/getUpdates",
                        json={"offset": self.offset, "timeout": 20, "allowed_updates": ["message", "edited_message", "callback_query"]},
                    )
                    response.raise_for_status()
                    data = response.json()
                    updates = data.get("result", [])
                    if updates:
                        logger.info("support_bot_updates", count=len(updates))
                    for update in updates:
                        update_id = update.get("update_id")
                        if isinstance(update_id, int):
                            self.offset = update_id + 1
                        if "callback_query" in update:
                            await self._process_callback(client, update["callback_query"])
                        if "message" in update:
                            await self._process_message(client, update["message"])
                        if "edited_message" in update:
                            await self._process_message(client, update["edited_message"])
                except Exception as exc:
                    logger.warning(f"support_bot_poll_failed: {exc}")
                    await asyncio.sleep(2)


async def main() -> None:  # noqa: N802
    bot = SupportBot()
    await bot.run()


if __name__ == "__main__":
    asyncio.run(main())
