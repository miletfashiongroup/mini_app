from __future__ import annotations

from uuid import UUID

import httpx

from brace_backend.core.config import settings
from brace_backend.core.exceptions import ValidationError
from brace_backend.db.uow import UnitOfWork
from brace_backend.domain.support import SupportTicket


class SupportService:
    _allowed_priorities = {"low", "normal", "high", "urgent"}

    async def create_ticket(
        self,
        uow: UnitOfWork,
        *,
        user_id: UUID,
        subject: str,
        message: str,
        order_id: UUID | None = None,
        priority: str = "normal",
        contact: str | None = None,
        category: str | None = None,
    ) -> SupportTicket:
        if not subject.strip():
            raise ValidationError("Subject is required.")
        if not message.strip():
            raise ValidationError("Message is required.")
        priority_value = (priority or "normal").strip().lower()
        if priority_value not in self._allowed_priorities:
            raise ValidationError("Invalid priority.")

        ticket = SupportTicket(
            user_id=user_id,
            order_id=order_id,
            subject=subject.strip(),
            message=message.strip(),
            priority=priority_value,
            status="open",
            meta={
                "contact": (contact or "").strip() or None,
                "category": (category or "").strip() or None,
            },
        )
        await uow.support_tickets.add(ticket)
        await uow.commit()
        await uow.session.refresh(ticket)

        # notify admins asynchronously (best-effort)
        await self._notify_admins(uow, ticket)
        return ticket

    async def _notify_admins(self, uow: UnitOfWork, ticket: SupportTicket) -> None:
        token = (settings.admin_bot_token or "").strip()
        admin_chat_ids = settings.admin_chat_ids
        if not token or not admin_chat_ids:
            return
        user = await uow.users.get_by_id(ticket.user_id)
        contact = None
        category = None
        if ticket.meta:
            contact = ticket.meta.get("contact")
            category = ticket.meta.get("category")
        lines = [
            "[support] Новое обращение",
            f"ID: {ticket.id}",
            f"Статус: {ticket.status}",
            f"Приоритет: {ticket.priority}",
            f"Тема: {ticket.subject}",
            f"Сообщение: {ticket.message}",
            f"Категория: {category or —}",
            f"Контакт: {contact or —}",
        ]
        if ticket.order_id:
            lines.append(f"Order ID: {ticket.order_id}")
        if user:
            lines.append("--- Пользователь")
            lines.append(f"User ID: {user.id}")
            lines.append(f"Telegram ID: {user.telegram_id or —}")
            lines.append(f"Username: @{user.username}" if user.username else "Username: —")
            lines.append(f"Телефон: {user.phone or —}")
        text = "\n".join(lines)
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        async with httpx.AsyncClient(timeout=5.0) as client:
            for chat_id in admin_chat_ids:
                try:
                    await client.post(url, json={"chat_id": chat_id, "text": text})
                except Exception:
                    continue

    async def list_tickets(
        self, uow: UnitOfWork, *, status: str | None, limit: int, offset: int
    ) -> list[SupportTicket]:
        return await uow.support_tickets.list_all(status=status, limit=limit, offset=offset)


support_service = SupportService()

__all__ = ["support_service", "SupportService"]
