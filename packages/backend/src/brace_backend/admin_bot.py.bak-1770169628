from __future__ import annotations

import asyncio
from html import escape
from typing import Any
from uuid import UUID

import httpx

from brace_backend.core.config import settings
from brace_backend.core.logging import logger
from brace_backend.db.session import session_manager
from brace_backend.db.uow import UnitOfWork
from brace_backend.services.order_service import order_service

STATUS_LABELS = {
    "pending": "–ù–æ–≤—ã–π",
    "processing": "–í –æ–±—Ä–∞–±–æ—Ç–∫–µ",
    "shipped": "–û—Ç–ø—Ä–∞–≤–ª–µ–Ω",
    "delivered": "–î–æ—Å—Ç–∞–≤–ª–µ–Ω",
    "cancelled": "–û—Ç–º–µ–Ω—ë–Ω",
}

STATUS_FILTERS: dict[str, str] = {
    "–≤—Å–µ –∑–∞–∫–∞–∑—ã": "",
    "–∑–∞–∫–∞–∑—ã": "",
    "–Ω–æ–≤—ã–µ –∑–∞–∫–∞–∑—ã": "pending",
    "–≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ": "processing",
    "–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã": "shipped",
    "–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã": "delivered",
    "–ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã": "delivered",
    "–æ—Ç–º–µ–Ω–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã": "cancelled",
    "–æ—Ç–º–µ–Ω—ë–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã": "cancelled",
}

ORDER_FORUM_CHAT_ID = -1003868543712
ORDER_STATUS_ICON = {
    "pending": "‚ùóÔ∏è",
    "processing": "‚ö°Ô∏è",
    "shipped": "üöö",
    "delivered": "‚úÖ",
    "cancelled": "‚ùóÔ∏è",
}
ORDER_ICON_CUSTOM = {
    "pending": "5379748062124056162",   # ‚ùóÔ∏è
    "processing": "5312016608254762256",  # ‚ö°Ô∏è
    "shipped": "5312322066328853156",    # üöö
    "delivered": "5237699328843200968",  # ‚úÖ
    "cancelled": "5379748062124056162",  # ‚ùóÔ∏è
}


def _order_actions_keyboard(order_id: str) -> dict[str, Any]:
    return {
        "inline_keyboard": [
            [
                {"text": "–ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å", "callback_data": f"status_menu:{order_id}"},
            ],
            [
                {"text": "–£–¥–∞–ª–∏—Ç—å –∑–∞–∫–∞–∑", "callback_data": f"delete_confirm:{order_id}"},
            ],
        ],
    }


def _status_keyboard(order_id: str) -> dict[str, Any]:
    return {
        "inline_keyboard": [
            [
                {"text": "–ù–æ–≤—ã–π", "callback_data": f"status:{order_id}:pending"},
                {"text": "–í –æ–±—Ä–∞–±–æ—Ç–∫–µ", "callback_data": f"status:{order_id}:processing"},
            ],
            [
                {"text": "–û—Ç–ø—Ä–∞–≤–ª–µ–Ω", "callback_data": f"status:{order_id}:shipped"},
                {"text": "–î–æ—Å—Ç–∞–≤–ª–µ–Ω", "callback_data": f"status:{order_id}:delivered"},
            ],
            [
                {"text": "–û—Ç–º–µ–Ω—ë–Ω", "callback_data": f"status:{order_id}:cancelled"},
                {"text": "–ù–∞–∑–∞–¥", "callback_data": f"actions:{order_id}"},
            ],
        ],
    }


def _delete_confirm_keyboard(order_id: str) -> dict[str, Any]:
    return {
        "inline_keyboard": [
            [
                {"text": "–î–∞, —É–¥–∞–ª–∏—Ç—å", "callback_data": f"delete:{order_id}"},
                {"text": "–ù–∞–∑–∞–¥", "callback_data": f"actions:{order_id}"},
            ]
        ],
    }


def _start_keyboard() -> dict[str, Any]:
    return {
        "keyboard": [
            [{"text": "–í—Å–µ –∑–∞–∫–∞–∑—ã"}, {"text": "–ù–æ–≤—ã–µ –∑–∞–∫–∞–∑—ã"}],
            [{"text": "–í –æ–±—Ä–∞–±–æ—Ç–∫–µ"}, {"text": "–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã"}],
            [{"text": "–î–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã"}, {"text": "–ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã"}],
            [{"text": "–û—Ç–º–µ–Ω–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã"}],
        ],
        "resize_keyboard": True,
        "one_time_keyboard": False,
    }


def _format_money(minor_units: int) -> str:
    return f"{minor_units / 100:.2f} RUB"


def _format_order_message(order, user=None) -> str:
    contact_lines = []
    if user:
        contact_lines = [
            "–ü–æ–∫—É–ø–∞—Ç–µ–ª—å:",
            f"User ID: {escape(str(user.id))}",
            f"Telegram ID: {escape(str(user.telegram_id))}" if user.telegram_id else "Telegram ID: ‚Äî",
            f"Username: @{escape(user.username)}" if user.username else "Username: ‚Äî",
            f"–¢–µ–ª–µ—Ñ–æ–Ω: {escape(user.phone)}" if user.phone else "–¢–µ–ª–µ—Ñ–æ–Ω: ‚Äî",
            "",
        ]
    lines = [
        "–ó–∞–∫–∞–∑",
        f"ID: {escape(str(order.id))}",
        f"–°—Ç–∞—Ç—É—Å: {STATUS_LABELS.get(order.status, order.status)}",
        f"–°—É–º–º–∞: {_format_money(order.total_amount_minor_units)}",
        "",
        "–°–æ—Å—Ç–∞–≤:",
    ]
    for item in order.items:
        product_code = None
        if item.product is not None:
            product_code = item.product.product_code
        lines.append(
            f"- {escape(product_code) if product_code else escape(str(item.product_id))} | "
            f"—Ä–∞–∑–º–µ—Ä {escape(item.size)} | x{item.quantity} | "
            f"{_format_money(item.unit_price_minor_units)}"
        )
    return "\n".join(contact_lines + lines)


def _topic_name(order) -> str:
    icon = ORDER_STATUS_ICON.get(order.status, "‚ùóÔ∏è")
    return f"{icon} –ó–∞–∫–∞–∑ #{order.id.hex[:6]} | {STATUS_LABELS.get(order.status, order.status)}"


class AdminBot:
    def __init__(self) -> None:
        self.token = (settings.admin_bot_token or "").strip()
        self.allowed_admins = set(settings.admin_chat_ids)
        self.api_base = f"https://api.telegram.org/bot{self.token}"
        self.offset = 0
        self.order_topic_cache: dict[UUID, int] = {}

    def _is_admin(self, user_id: int) -> bool:
        return user_id in self.allowed_admins

    async def _send_message(
        self, client: httpx.AsyncClient, chat_id: int, text: str, reply_markup: dict | None = None, thread_id: int | None = None
    ) -> None:
        payload: dict[str, Any] = {"chat_id": chat_id, "text": text}
        if reply_markup:
            payload["reply_markup"] = reply_markup
        if thread_id is not None:
            payload["message_thread_id"] = thread_id
        response = await client.post(f"{self.api_base}/sendMessage", json=payload)
        response.raise_for_status()

    async def _edit_message_markup(
        self,
        client: httpx.AsyncClient,
        chat_id: int,
        message_id: int,
        reply_markup: dict | None,
    ) -> None:
        payload: dict[str, Any] = {"chat_id": chat_id, "message_id": message_id}
        if reply_markup is not None:
            payload["reply_markup"] = reply_markup
        response = await client.post(f"{self.api_base}/editMessageReplyMarkup", json=payload)
        response.raise_for_status()

    async def _edit_message_text(
        self,
        client: httpx.AsyncClient,
        chat_id: int,
        message_id: int,
        text: str,
        reply_markup: dict | None = None,
    ) -> None:
        payload: dict[str, Any] = {"chat_id": chat_id, "message_id": message_id, "text": text}
        if reply_markup is not None:
            payload["reply_markup"] = reply_markup
        response = await client.post(f"{self.api_base}/editMessageText", json=payload)
        response.raise_for_status()

    async def _delete_message(
        self,
        client: httpx.AsyncClient,
        chat_id: int,
        message_id: int,
    ) -> None:
        payload: dict[str, Any] = {"chat_id": chat_id, "message_id": message_id}
        response = await client.post(f"{self.api_base}/deleteMessage", json=payload)
        response.raise_for_status()

    async def _answer_callback(self, client: httpx.AsyncClient, callback_id: str, text: str) -> None:
        response = await client.post(
            f"{self.api_base}/answerCallbackQuery",
            json={"callback_query_id": callback_id, "text": text},
        )
        response.raise_for_status()

    async def _set_status(self, order_id: UUID, status: str):
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            return await order_service.set_status_admin(uow, order_id=order_id, status=status)

    async def _get_order(self, order_id: UUID):
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            order = await uow.orders.get_by_id(order_id=order_id)
            if order:
                _ = order.items
                _ = order.user or await uow.users.get(order.user_id)
            return order

    async def _get_order_message(self, order_id: UUID) -> str:
        order = await self._get_order(order_id)
        if not order:
            return "–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω."
        user = order.user or None
        return _format_order_message(order, user)

    async def _delete_order(self, order_id: UUID) -> None:
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            await order_service.delete_order_admin(uow, order_id=order_id)

    async def _edit_topic(self, client: httpx.AsyncClient, thread_id: int, order) -> None:
        payload = {
            "chat_id": ORDER_FORUM_CHAT_ID,
            "message_thread_id": thread_id,
            "name": _topic_name(order)[:128],
            "icon_custom_emoji_id": ORDER_ICON_CUSTOM.get(order.status),
        }
        try:
            await client.post(f"{self.api_base}/editForumTopic", json=payload)
        except Exception as exc:  # pragma: no cover
            logger.warning("admin_bot_edit_topic_failed", order_id=str(order.id), thread_id=thread_id, error=str(exc))

    async def _ensure_topic(self, client: httpx.AsyncClient, order) -> int | None:
        if order.id in self.order_topic_cache:
            return self.order_topic_cache[order.id]
        if not ORDER_FORUM_CHAT_ID:
            return None
        try:
            resp = await client.post(
                f"{self.api_base}/createForumTopic",
                json={
                    "chat_id": ORDER_FORUM_CHAT_ID,
                    "name": _topic_name(order),
                    "icon_custom_emoji_id": ORDER_ICON_CUSTOM.get(order.status),
                },
            )
            data = resp.json()
            if data.get("ok") and data.get("result", {}).get("message_thread_id"):
                thread_id = int(data["result"]["message_thread_id"])
                self.order_topic_cache[order.id] = thread_id
                return thread_id
            logger.warning("admin_bot_create_topic_failed", order_id=str(order.id), response=data)
        except Exception as exc:  # pragma: no cover
            logger.warning("admin_bot_create_topic_error", order_id=str(order.id), error=str(exc))
        return None

    async def _send_order_to_forum(self, client: httpx.AsyncClient, order) -> None:
        thread_id = await self._ensure_topic(client, order)
        if thread_id is None:
            return
        await self._edit_topic(client, thread_id, order)
        text = _format_order_message(order, order.user or None)
        try:
            await self._send_message(
                client,
                ORDER_FORUM_CHAT_ID,
                text,
                reply_markup=_order_actions_keyboard(str(order.id)),
                thread_id=thread_id,
            )
        except Exception as exc:
            logger.warning("admin_bot_forum_send_failed", order_id=str(order.id), error=str(exc))

    async def _handle_command(self, client: httpx.AsyncClient, chat_id: int, text: str) -> None:
        raw_text = text.strip()
        raw_lower = raw_text.lower()
        if raw_lower in STATUS_FILTERS:
            status = STATUS_FILTERS[raw_lower]
            raw_text = "/orders" if not status else f"/orders {status}"
        parts = raw_text.split()
        command = parts[0].lower()

        if command in ("/start", "/help"):
            await self._send_message(
                client,
                chat_id,
                "–ê–¥–º–∏–Ω-–±–æ—Ç –∑–∞–∫–∞–∑–æ–≤.\n\n"
                "–ö–æ–º–∞–Ω–¥—ã:\n"
                "/orders ‚Äî –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–∫–∞–∑—ã\n"
                "/order <id> ‚Äî –¥–µ—Ç–∞–ª–∏ –∑–∞–∫–∞–∑–∞\n",
                reply_markup=_start_keyboard(),
            )
            return

        if command == "/orders":
            status = parts[1].lower() if len(parts) > 1 else None
            async with session_manager.session() as session:
                uow = UnitOfWork(session)
                orders = await uow.orders.list_recent(limit=10, status=status)
                if not orders:
                    await self._send_message(client, chat_id, "–ó–∞–∫–∞–∑–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç.")
                    return
                for order in orders:
                    user = order.user or await uow.users.get(order.user_id)
                    await self._send_message(
                        client,
                        chat_id,
                        _format_order_message(order, user),
                        reply_markup=_order_actions_keyboard(str(order.id)),
                    )
                    await self._send_order_to_forum(client, order)
            return

        if command == "/order":
            if len(parts) < 2:
                await self._send_message(client, chat_id, "–£–∫–∞–∂–∏ id –∑–∞–∫–∞–∑–∞: /order <id>")
                return
            try:
                order_id = UUID(parts[1])
            except ValueError:
                await self._send_message(client, chat_id, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π id –∑–∞–∫–∞–∑–∞.")
                return
            async with session_manager.session() as session:
                uow = UnitOfWork(session)
                order = await uow.orders.get_by_id(order_id=order_id)
                if not order:
                    await self._send_message(client, chat_id, "–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                    return
                user = await uow.users.get(order.user_id)
                message = _format_order_message(order, user)
                await self._send_message(
                    client,
                    chat_id,
                    message,
                    reply_markup=_order_actions_keyboard(str(order.id)),
                )
            await self._send_order_to_forum(client, order)
            return

        await self._send_message(client, chat_id, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. /help")

    async def _handle_callback(self, client: httpx.AsyncClient, callback: dict[str, Any]) -> None:
        callback_id = callback.get("id")
        from_user = callback.get("from", {})
        user_id = from_user.get("id")
        data = callback.get("data", "")
        if not callback_id or not isinstance(user_id, int):
            return
        if not self._is_admin(user_id):
            await self._answer_callback(client, callback_id, "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
            return
        if not data.startswith("status:"):
            if data.startswith("status_menu:"):
                order_id_str = data.split(":", 1)[1]
                try:
                    order_id = UUID(order_id_str)
                except ValueError:
                    await self._answer_callback(client, callback_id, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–∫–∞–∑.")
                    return
                message = callback.get("message", {})
                chat_id = message.get("chat", {}).get("id")
                message_id = message.get("message_id")
                if isinstance(chat_id, int) and isinstance(message_id, int):
                    await self._edit_message_markup(
                        client,
                        chat_id,
                        message_id,
                        _status_keyboard(str(order_id)),
                    )
                await self._answer_callback(client, callback_id, "–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞—Ç—É—Å.")
                return
            if data.startswith("delete_confirm:"):
                order_id_str = data.split(":", 1)[1]
                try:
                    UUID(order_id_str)
                except ValueError:
                    await self._answer_callback(client, callback_id, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–∫–∞–∑.")
                    return
                message = callback.get("message", {})
                chat_id = message.get("chat", {}).get("id")
                message_id = message.get("message_id")
                if isinstance(chat_id, int) and isinstance(message_id, int):
                    await self._edit_message_markup(
                        client,
                        chat_id,
                        message_id,
                        _delete_confirm_keyboard(order_id_str),
                    )
                await self._answer_callback(client, callback_id, "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —É–¥–∞–ª–µ–Ω–∏–µ.")
                return
            if data.startswith("actions:"):
                order_id_str = data.split(":", 1)[1]
                message = callback.get("message", {})
                chat_id = message.get("chat", {}).get("id")
                message_id = message.get("message_id")
                if isinstance(chat_id, int) and isinstance(message_id, int):
                    await self._edit_message_markup(
                        client,
                        chat_id,
                        message_id,
                        _order_actions_keyboard(order_id_str),
                    )
                await self._answer_callback(client, callback_id, "–ì–æ—Ç–æ–≤–æ.")
                return
            if data.startswith("delete:"):
                order_id_str = data.split(":", 1)[1]
                try:
                    order_id = UUID(order_id_str)
                except ValueError:
                    await self._answer_callback(client, callback_id, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–∫–∞–∑.")
                    return
                try:
                    await self._delete_order(order_id)
                    await self._answer_callback(client, callback_id, "–ó–∞–∫–∞–∑ —É–¥–∞–ª–µ–Ω.")
                    message = callback.get("message", {})
                    chat_id = message.get("chat", {}).get("id")
                    message_id = message.get("message_id")
                    if isinstance(chat_id, int) and isinstance(message_id, int):
                        try:
                            await self._delete_message(client, chat_id, message_id)
                        except Exception as exc:
                            logger.warning(
                                "admin_bot_delete_message_failed",
                                order_id=str(order_id),
                                error=str(exc),
                            )
                        await self._send_message(
                            client,
                            chat_id,
                            f"–ó–∞–∫–∞–∑ {order_id} —É–¥–∞–ª–µ–Ω.",
                        )
                except Exception as exc:
                    logger.warning("admin_bot_delete_failed", order_id=str(order_id), error=str(exc))
                    await self._answer_callback(client, callback_id, "–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–∫–∞–∑.")
                return
            await self._answer_callback(client, callback_id, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ.")
            return
        _, order_id_str, status = data.split(":", 2)
        try:
            order_id = UUID(order_id_str)
        except ValueError:
            await self._answer_callback(client, callback_id, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–∫–∞–∑.")
            return
        try:
            await self._set_status(order_id, status)
            await self._answer_callback(client, callback_id, f"–°—Ç–∞—Ç—É—Å: {STATUS_LABELS.get(status, status)}")
            message = callback.get("message", {})
            chat_id = message.get("chat", {}).get("id")
            message_id = message.get("message_id")
            order = await self._get_order(order_id)
            if order and isinstance(chat_id, int) and isinstance(message_id, int):
                updated_text = _format_order_message(order, order.user or None)
                await self._edit_message_text(
                    client,
                    chat_id,
                    message_id,
                    updated_text,
                    reply_markup=_order_actions_keyboard(order_id_str),
                )
            if order:
                await self._send_order_to_forum(client, order)
        except Exception as exc:
            logger.warning("admin_bot_status_failed", order_id=str(order_id), error=str(exc))
            await self._answer_callback(client, callback_id, "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å.")

    async def run(self) -> None:
        if not self.token or not self.allowed_admins:
            logger.warning("admin_bot_disabled", reason="missing_token_or_admins")
            while True:
                await asyncio.sleep(60)

        async with httpx.AsyncClient(timeout=httpx.Timeout(25.0)) as client:
            logger.info("admin_bot_started", admins=len(self.allowed_admins))
            while True:
                try:
                    response = await client.post(
                        f"{self.api_base}/getUpdates",
                        json={"offset": self.offset, "timeout": 20},
                    )
                    response.raise_for_status()
                    data = response.json()
                    updates = data.get("result", [])
                    for update in updates:
                        update_id = update.get("update_id")
                        if isinstance(update_id, int):
                            self.offset = update_id + 1
                        if "message" in update:
                            message = update["message"]
                            chat = message.get("chat", {})
                            chat_id = chat.get("id")
                            text = message.get("text") or ""
                            user_id = message.get("from", {}).get("id")
                            if not isinstance(chat_id, int) or not isinstance(user_id, int):
                                continue
                            if not self._is_admin(user_id):
                                await self._send_message(client, chat_id, "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
                                continue
                            await self._handle_command(client, chat_id, text)
                        if "callback_query" in update:
                            await self._handle_callback(client, update["callback_query"])
                except Exception as exc:
                    logger.warning("admin_bot_poll_failed", error=str(exc))
                    await asyncio.sleep(2)


async def main() -> None:
    bot = AdminBot()
    await bot.run()


if __name__ == "__main__":
    asyncio.run(main())
