from __future__ import annotations

import asyncio
from html import escape
from typing import Any
from uuid import UUID

import httpx

from brace_backend.core.config import settings
from brace_backend.core.logging import logger
from brace_backend.db.session import session_manager
from brace_backend.db.uow import UnitOfWork
from brace_backend.services.order_service import order_service

STATUS_LABELS = {
    "pending": "Новый",
    "processing": "В обработке",
    "shipped": "Отправлен",
    "delivered": "Доставлен",
    "cancelled": "Отменён",
}

STATUS_FILTERS: dict[str, str] = {
    "все заказы": "",
    "заказы": "",
    "новые заказы": "pending",
    "в обработке": "processing",
    "отправленные заказы": "shipped",
    "доставленные заказы": "delivered",
    "полученные заказы": "delivered",
    "отмененные заказы": "cancelled",
    "отменённые заказы": "cancelled",
}

ORDER_FORUM_CHAT_ID = int(getattr(settings, "admin_orders_chat_id", 0) or 0) or 3868543712


def _order_actions_keyboard(order_id: str) -> dict[str, Any]:
    return {
        "inline_keyboard": [
            [
                {"text": "Изменить статус", "callback_data": f"status_menu:{order_id}"},
            ],
            [
                {"text": "Удалить заказ", "callback_data": f"delete_confirm:{order_id}"},
            ],
        ],
    }


def _status_keyboard(order_id: str) -> dict[str, Any]:
    return {
        "inline_keyboard": [
            [
                {"text": "Новый", "callback_data": f"status:{order_id}:pending"},
                {"text": "В обработке", "callback_data": f"status:{order_id}:processing"},
            ],
            [
                {"text": "Отправлен", "callback_data": f"status:{order_id}:shipped"},
                {"text": "Доставлен", "callback_data": f"status:{order_id}:delivered"},
            ],
            [
                {"text": "Отменён", "callback_data": f"status:{order_id}:cancelled"},
                {"text": "Назад", "callback_data": f"actions:{order_id}"},
            ],
        ],
    }


def _delete_confirm_keyboard(order_id: str) -> dict[str, Any]:
    return {
        "inline_keyboard": [
            [
                {"text": "Да, удалить", "callback_data": f"delete:{order_id}"},
                {"text": "Назад", "callback_data": f"actions:{order_id}"},
            ]
        ],
    }


def _start_keyboard() -> dict[str, Any]:
    return {
        "keyboard": [
            [{"text": "Все заказы"}, {"text": "Новые заказы"}],
            [{"text": "В обработке"}, {"text": "Отправленные заказы"}],
            [{"text": "Доставленные заказы"}, {"text": "Полученные заказы"}],
            [{"text": "Отмененные заказы"}],
        ],
        "resize_keyboard": True,
        "one_time_keyboard": False,
    }


def _format_money(minor_units: int) -> str:
    return f"{minor_units / 100:.2f} RUB"


def _format_order_message(order, user=None) -> str:
    contact_lines = []
    if user:
        contact_lines = [
            "Покупатель:",
            f"User ID: {escape(str(user.id))}",
            f"Telegram ID: {escape(str(user.telegram_id))}" if user.telegram_id else "Telegram ID: —",
            f"Username: @{escape(user.username)}" if user.username else "Username: —",
            f"Телефон: {escape(user.phone)}" if user.phone else "Телефон: —",
            "",
        ]
    lines = [
        "Заказ",
        f"ID: {escape(str(order.id))}",
        f"Статус: {STATUS_LABELS.get(order.status, order.status)}",
        f"Сумма: {_format_money(order.total_amount_minor_units)}",
        "",
        "Состав:",
    ]
    for item in order.items:
        product_code = None
        if item.product is not None:
            product_code = item.product.product_code
        lines.append(
            f"- {escape(product_code) if product_code else escape(str(item.product_id))} | "
            f"размер {escape(item.size)} | x{item.quantity} | "
            f"{_format_money(item.unit_price_minor_units)}"
        )
    return "\n".join(contact_lines + lines)


def _topic_name(order) -> str:
    return f"Заказ #{str(order.id)[:6]} | {STATUS_LABELS.get(order.status, order.status)}"


class AdminBot:
    def __init__(self) -> None:
        self.token = (settings.admin_bot_token or "").strip()
        self.allowed_admins = set(settings.admin_chat_ids)
        self.api_base = f"https://api.telegram.org/bot{self.token}"
        self.offset = 0
        self.order_topic_cache: dict[UUID, int] = {}

    def _is_admin(self, user_id: int) -> bool:
        return user_id in self.allowed_admins

    async def _send_message(
        self, client: httpx.AsyncClient, chat_id: int, text: str, reply_markup: dict | None = None, thread_id: int | None = None
    ) -> None:
        payload: dict[str, Any] = {"chat_id": chat_id, "text": text}
        if reply_markup:
            payload["reply_markup"] = reply_markup
        if thread_id is not None:
            payload["message_thread_id"] = thread_id
        response = await client.post(f"{self.api_base}/sendMessage", json=payload)
        response.raise_for_status()

    async def _edit_message_markup(
        self,
        client: httpx.AsyncClient,
        chat_id: int,
        message_id: int,
        reply_markup: dict | None,
    ) -> None:
        payload: dict[str, Any] = {"chat_id": chat_id, "message_id": message_id}
        if reply_markup is not None:
            payload["reply_markup"] = reply_markup
        response = await client.post(f"{self.api_base}/editMessageReplyMarkup", json=payload)
        response.raise_for_status()

    async def _edit_message_text(
        self,
        client: httpx.AsyncClient,
        chat_id: int,
        message_id: int,
        text: str,
        reply_markup: dict | None = None,
    ) -> None:
        payload: dict[str, Any] = {"chat_id": chat_id, "message_id": message_id, "text": text}
        if reply_markup is not None:
            payload["reply_markup"] = reply_markup
        response = await client.post(f"{self.api_base}/editMessageText", json=payload)
        response.raise_for_status()

    async def _delete_message(
        self,
        client: httpx.AsyncClient,
        chat_id: int,
        message_id: int,
    ) -> None:
        payload: dict[str, Any] = {"chat_id": chat_id, "message_id": message_id}
        response = await client.post(f"{self.api_base}/deleteMessage", json=payload)
        response.raise_for_status()

    async def _answer_callback(self, client: httpx.AsyncClient, callback_id: str, text: str) -> None:
        response = await client.post(
            f"{self.api_base}/answerCallbackQuery",
            json={"callback_query_id": callback_id, "text": text},
        )
        response.raise_for_status()

    async def _set_status(self, order_id: UUID, status: str):
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            return await order_service.set_status_admin(uow, order_id=order_id, status=status)

    async def _get_order(self, order_id: UUID):
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            order = await uow.orders.get_by_id(order_id=order_id)
            if order:
                _ = order.items  # preload
                _ = order.user or await uow.users.get(order.user_id)
            return order

    async def _get_order_message(self, order_id: UUID) -> str:
        order = await self._get_order(order_id)
        if not order:
            return "Заказ не найден."
        user = order.user or None
        return _format_order_message(order, user)

    async def _delete_order(self, order_id: UUID) -> None:
        async with session_manager.session() as session:
            uow = UnitOfWork(session)
            await order_service.delete_order_admin(uow, order_id=order_id)

    async def _ensure_topic(self, client: httpx.AsyncClient, order) -> int | None:
        if order.id in self.order_topic_cache:
            return self.order_topic_cache[order.id]
        if not ORDER_FORUM_CHAT_ID:
            return None
        try:
            resp = await client.post(
                f"{self.api_base}/createForumTopic",
                json={"chat_id": ORDER_FORUM_CHAT_ID, "name": _topic_name(order)},
            )
            data = resp.json()
            if data.get("ok") and data.get("result", {}).get("message_thread_id"):
                thread_id = int(data["result"]["message_thread_id"])
                self.order_topic_cache[order.id] = thread_id
                return thread_id
            logger.warning("admin_bot_create_topic_failed", order_id=str(order.id), response=data)
        except Exception as exc:  # pragma: no cover
            logger.warning("admin_bot_create_topic_error", order_id=str(order.id), error=str(exc))
        return None

    async def _send_order_to_forum(self, client: httpx.AsyncClient, order) -> None:
        thread_id = await self._ensure_topic(client, order)
        if thread_id is None:
            return
        text = _format_order_message(order, order.user or None)
        try:
            await self._send_message(client, ORDER_FORUM_CHAT_ID, text, reply_markup=_order_actions_keyboard(str(order.id)), thread_id=thread_id)
        except Exception as exc:
            logger.warning("admin_bot_forum_send_failed", order_id=str(order.id), error=str(exc))

    async def _handle_command(self, client: httpx.AsyncClient, chat_id: int, text: str) -> None:
        raw_text = text.strip()
        raw_lower = raw_text.lower()
        if raw_lower in STATUS_FILTERS:
            status = STATUS_FILTERS[raw_lower]
            raw_text = "/orders" if not status else f"/orders {status}"
        parts = raw_text.split()
        command = parts[0].lower()

        if command in ("/start", "/help"):
            await self._send_message(
                client,
                chat_id,
                "Админ-бот заказов.\n\n"
                "Команды:\n"
                "/orders — последние заказы\n"
                "/order <id> — детали заказа\n",
                reply_markup=_start_keyboard(),
            )
            return

        if command == "/orders":
            status = parts[1].lower() if len(parts) > 1 else None
            async with session_manager.session() as session:
                uow = UnitOfWork(session)
                orders = await uow.orders.list_recent(limit=10, status=status)
                if not orders:
                    await self._send_message(client, chat_id, "Заказов пока нет.")
                    return
                for order in orders:
                    user = order.user or await uow.users.get(order.user_id)
                    await self._send_message(
                        client,
                        chat_id,
                        _format_order_message(order, user),
                        reply_markup=_order_actions_keyboard(str(order.id)),
                    )
                    await self._send_order_to_forum(client, order)
            return

        if command == "/order":
            if len(parts) < 2:
                await self._send_message(client, chat_id, "Укажи id заказа: /order <id>")
                return
            try:
                order_id = UUID(parts[1])
            except ValueError:
                await self._send_message(client, chat_id, "Некорректный id заказа.")
                return
            async with session_manager.session() as session:
                uow = UnitOfWork(session)
                order = await uow.orders.get_by_id(order_id=order_id)
                if not order:
                    await self._send_message(client, chat_id, "Заказ не найден.")
                    return
                user = await uow.users.get(order.user_id)
                message = _format_order_message(order, user)
                await self._send_message(
                    client,
                    chat_id,
                    message,
                    reply_markup=_order_actions_keyboard(str(order.id)),
                )
            await self._send_order_to_forum(client, order)
            return

        await self._send_message(client, chat_id, "Неизвестная команда. /help")

    async def _handle_callback(self, client: httpx.AsyncClient, callback: dict[str, Any]) -> None:
        callback_id = callback.get("id")
        from_user = callback.get("from", {})
        user_id = from_user.get("id")
        data = callback.get("data", "")
        if not callback_id or not isinstance(user_id, int):
            return
        if not self._is_admin(user_id):
            await self._answer_callback(client, callback_id, "Нет доступа.")
            return
        if not data.startswith("status:"):
            if data.startswith("status_menu:"):
                order_id_str = data.split(":", 1)[1]
                try:
                    order_id = UUID(order_id_str)
                except ValueError:
                    await self._answer_callback(client, callback_id, "Некорректный заказ.")
                    return
                message = callback.get("message", {})
                chat_id = message.get("chat", {}).get("id")
                message_id = message.get("message_id")
                if isinstance(chat_id, int) and isinstance(message_id, int):
                    await self._edit_message_markup(
                        client,
                        chat_id,
                        message_id,
                        _status_keyboard(str(order_id)),
                    )
                await self._answer_callback(client, callback_id, "Выберите статус.")
                return
            if data.startswith("delete_confirm:"):
                order_id_str = data.split(":", 1)[1]
                try:
                    UUID(order_id_str)
                except ValueError:
                    await self._answer_callback(client, callback_id, "Некорректный заказ.")
                    return
                message = callback.get("message", {})
                chat_id = message.get("chat", {}).get("id")
                message_id = message.get("message_id")
                if isinstance(chat_id, int) and isinstance(message_id, int):
                    await self._edit_message_markup(
                        client,
                        chat_id,
                        message_id,
                        _delete_confirm_keyboard(order_id_str),
                    )
                await self._answer_callback(client, callback_id, "Подтвердите удаление.")
                return
            if data.startswith("actions:"):
                order_id_str = data.split(":", 1)[1]
                message = callback.get("message", {})
                chat_id = message.get("chat", {}).get("id")
                message_id = message.get("message_id")
                if isinstance(chat_id, int) and isinstance(message_id, int):
                    await self._edit_message_markup(
                        client,
                        chat_id,
                        message_id,
                        _order_actions_keyboard(order_id_str),
                    )
                await self._answer_callback(client, callback_id, "Готово.")
                return
            if data.startswith("delete:"):
                order_id_str = data.split(":", 1)[1]
                try:
                    order_id = UUID(order_id_str)
                except ValueError:
                    await self._answer_callback(client, callback_id, "Некорректный заказ.")
                    return
                try:
                    await self._delete_order(order_id)
                    await self._answer_callback(client, callback_id, "Заказ удален.")
                    message = callback.get("message", {})
                    chat_id = message.get("chat", {}).get("id")
                    message_id = message.get("message_id")
                    if isinstance(chat_id, int) and isinstance(message_id, int):
                        try:
                            await self._delete_message(client, chat_id, message_id)
                        except Exception as exc:
                            logger.warning(
                                "admin_bot_delete_message_failed",
                                order_id=str(order_id),
                                error=str(exc),
                            )
                        await self._send_message(
                            client,
                            chat_id,
                            f"Заказ {order_id} удален.",
                        )
                except Exception as exc:
                    logger.warning("admin_bot_delete_failed", order_id=str(order_id), error=str(exc))
                    await self._answer_callback(client, callback_id, "Не удалось удалить заказ.")
                return
            await self._answer_callback(client, callback_id, "Неизвестное действие.")
            return
        _, order_id_str, status = data.split(":", 2)
        try:
            order_id = UUID(order_id_str)
        except ValueError:
            await self._answer_callback(client, callback_id, "Некорректный заказ.")
            return
        try:
            await self._set_status(order_id, status)
            await self._answer_callback(client, callback_id, f"Статус: {STATUS_LABELS.get(status, status)}")
            message = callback.get("message", {})
            chat_id = message.get("chat", {}).get("id")
            message_id = message.get("message_id")
            order = await self._get_order(order_id)
            if order and isinstance(chat_id, int) and isinstance(message_id, int):
                updated_text = _format_order_message(order, order.user or None)
                await self._edit_message_text(
                    client,
                    chat_id,
                    message_id,
                    updated_text,
                    reply_markup=_order_actions_keyboard(order_id_str),
                )
            if order:
                await self._send_order_to_forum(client, order)
        except Exception as exc:
            logger.warning("admin_bot_status_failed", order_id=str(order_id), error=str(exc))
            await self._answer_callback(client, callback_id, "Не удалось обновить статус.")

    async def run(self) -> None:
        if not self.token or not self.allowed_admins:
            logger.warning("admin_bot_disabled", reason="missing_token_or_admins")
            while True:
                await asyncio.sleep(60)

        async with httpx.AsyncClient(timeout=httpx.Timeout(25.0)) as client:
            logger.info("admin_bot_started", admins=len(self.allowed_admins))
            while True:
                try:
                    response = await client.post(
                        f"{self.api_base}/getUpdates",
                        json={"offset": self.offset, "timeout": 20},
                    )
                    response.raise_for_status()
                    data = response.json()
                    updates = data.get("result", [])
                    for update in updates:
                        update_id = update.get("update_id")
                        if isinstance(update_id, int):
                            self.offset = update_id + 1
                        if "message" in update:
                            message = update["message"]
                            chat = message.get("chat", {})
                            chat_id = chat.get("id")
                            text = message.get("text") or ""
                            user_id = message.get("from", {}).get("id")
                            if not isinstance(chat_id, int) or not isinstance(user_id, int):
                                continue
                            if not self._is_admin(user_id):
                                await self._send_message(client, chat_id, "Нет доступа.")
                                continue
                            await self._handle_command(client, chat_id, text)
                        if "callback_query" in update:
                            await self._handle_callback(client, update["callback_query"])
                except Exception as exc:
                    logger.warning("admin_bot_poll_failed", error=str(exc))
                    await asyncio.sleep(2)


async def main() -> None:
    bot = AdminBot()
    await bot.run()


if __name__ == "__main__":
    asyncio.run(main())
